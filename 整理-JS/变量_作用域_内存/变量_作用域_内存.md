## 变量

#### 值类型和引用类型

- 值类型：

  - undefined :  let a
  - string  :   const s = 'abc'
  - number  :  const n = 100
  - boolean  :  const b = true
  - null  ： null是基本数据类型，但是typeof null为**object**,这是因为在js存储中对象是以000开头的，而null是一个空，相当于全0，所以typeof null也是object
  - symbol  :  const s = Symbol('s')  // ES6

- 引用类型

  - Object

  - Array

  - Date

  - RegExp

  - Function

  - 基本包装类型（Boolean、Number、String）

  - 单体内置对象（Global对象、Math对象）

    

#### 值类型和引用类型的区别

- 值类型
  	1、占用空间固定，保存在栈中
  	2、保存与复制的是值本身
  	3、使用typeof检测数据的类型
  	4、基本类型数据是值类型
  引用类型
  	1、占用空间不固定，保存在堆中                           	
      2、保存与复制的是指向对象的一个指针
      3、使用instanceof检测数据类型
      4、使用new()方法构造出的对象是引用型

  

#### 值类型和引用类型的判断

- **typpeof**

  - 一般使用typeof判断值类型

    - typeof NaN ->“number”

  - 使用typeof判断引用类型的情况

    ```javascript
    typeof [1,2] //数组，输出：object
    typeof {a:1,b:2} //对象，输出：object
    typeof new Number(2) //new Number(2),输出：object
    typeof function(){} //函数，输出：function
    ```

  - typeof null 的历史：第一代JavaScript引擎中的JavaScript值表示为32位的字符。最低的3位作为一种标识，表示值是对象、整数、浮点数或者布尔值。
    **对象的标示是000**。而为了表现null值，引擎使用了机器语言NULL指针，该字符的所有位都是0。而typeof就是检测值的标志位，这就是为什么它会被认为是一个对象的原因。

- **instanceof**

  - 基本类型的判断用typeof，引用类型的判断用instanceof

    ```javascript
    [1,2] instanceof Object //输出：true
    /*************************************************/
    var obj = {a:1,b:2} 
    obj instanceof Object //输出：true
    /*************************************************/
    var fun = function(){} ;
    fun instanceof Object //输出：true
    /*************************************************/
    //自定义一个构造函数
    function Fun(){}
    //利用上面的构造函数构造一个实例
    var fun1 = new Fun()
    
    console.log(fun1 instanceof Fun)      //true
    console.log(fun1 instanceof Function) //false
    console.log(fun1 instanceof Object)   //true
    /*************************************************/
    null instanceof Object //输出：false;通过instanceof可知，null不是引用类型
    ```

  - 原理：

    - 通过原型链实现

    - `Instanceof`的判断规则是：沿着A的`__proto__`这条线来找，同时沿着B的`prototype`这条线来找，如果能找到同一个引用，返回`true`，否则返回`false`。

    - ```javascript
      function instance_of(L, R) {         // L 表示instanceof左边，R 表示instanceof右边
      		let O = R.prototype;         // 取 R 的显示原型
      		L = L.__proto__;             // 取 L 的隐式原型
      		while (true) {               // 循环执行，直到 O 严格等于 L
      			if (L === null) return false;
      			if (O === L) return true;
      			L = L.__proto__;
      		}
      	}
      ```

  - 弊端：

    - ```javascript
      let a = 1
      	console.log(a instanceof Number)       // false
      
      //原因：instanceof 用来判断的是 object 类型的，如果不是则会返回 false；
      ```

    - ```javascript
      console.log(Number instanceof Number)  // false
      console.log(String instanceof String)  // false
      console.log(Foo instanceof Foo)        // false
      //Number 和 String 都是构造函数，原型链上都是由 Function 实例化出来的
      
      Function instanceof Object;//true
      Object instanceof Function;//true
      /*
      Function.__proto__.__proto__ === Object.prototype;//true
      Object.__proto__ === Function.prototype;//true
      */
      ```

- 其他判断方法：

  - number类型：
    - **NaN == NaN :false** NaN和任何其它值都不相等
    - isNaN（0）->false
      isNaN（NaN）->true
      **isNaN(‘12’)–>false**
    - Number(‘12’) ->12
      Number(‘12px’) ->NaN
    - Number([])。把引用数据类型转换为number，首先把引用数据类型转换为字符串（toString），在把字符串转换为number即可 例如：[]->’’ ‘’->0

## 作用域



## 内存

